#### Esta es la solucion de mi actividad ✍️
---

#### **1. Comprensión previa vs. actual**
Antes de esta unidad, tenía una idea muy vaga sobre los patrones de diseño. Había escuchado sobre ellos, especialmente en videos o artículos sobre buenas prácticas de programación, pero no entendía bien cómo se aplicaban ni para qué servían realmente. Ahora, después de haber trabajado con Observer, Factory y State de forma práctica en un proyecto, siento que tengo una comprensión mucho más clara y funcional. No solo sé en qué consisten, sino también cuándo conviene usarlos. Por ejemplo, comprendí que Observer es ideal para desacoplar clases que necesitan comunicarse constantemente sin depender directamente entre sí, lo que hace el código más flexible. Factory me ayudó a centralizar la creación de objetos, y State fue clave para manejar distintos comportamientos dinámicamente. Esta experiencia práctica hizo toda la diferencia.

#### **2. Facilidad y dificultad**
Lo más fácil de entender fue el patrón Factory. Me pareció muy intuitivo y lógico tener una clase encargada de crear objetos según ciertas condiciones. Además, fue sencillo de implementar en mi proyecto porque me permitió separar la lógica de creación de formas o elementos visuales, haciendo que el código estuviera más ordenado. También fue relativamente sencillo reconocer su utilidad desde el principio, porque ya había tenido dificultades antes con muchos condicionales en el setup o en la lógica principal del programa. Factory simplificó eso.

#### **3. Retos y soluciones**
Lo más difícil para mí fue implementar correctamente el patrón State. Al principio me costó entender cómo diseñar bien los distintos estados y cómo lograr que el cambio de estado afectara correctamente al comportamiento del programa. También tuve problemas con la transición entre estados, ya que no estaba seguro de dónde debía ocurrir el cambio. Para superarlo, leí ejemplos prácticos, revisé el material de la unidad varias veces y consulté algunas fuentes externas que explicaban el patrón con videojuegos o semáforos. Ver casos visuales me ayudó bastante. Además, dividir el código en clases bien diferenciadas y testear cada una por separado me ayudó a encontrar errores más fácilmente.

#### **4. Mejora del aprendizaje**
Si pudiera volver a realizar esta unidad, creo que dedicaría más tiempo al diseño inicial del proyecto, sobre todo a planear las clases y sus responsabilidades antes de empezar a programar. Me di cuenta de que improvisar el diseño a medida que programaba hizo que tuviera que reestructurar muchas partes del código después. También me gustaría hacer más diagramas de clases y de estados para visualizar mejor la arquitectura antes de codificar. Además, exploraría ejemplos adicionales en línea y trataría de experimentar con patrones en pequeños programas antes de integrarlos al proyecto final.

#### **5. Transferencia y utilidad futura**
Definitivamente creo que estos patrones de diseño me serán útiles en el futuro, tanto en otros cursos de programación como en proyectos personales. Por ejemplo, si trabajo en una app interactiva o en un videojuego, el patrón State sería esencial para controlar las fases del juego o la interacción del usuario. Observer puede ser útil en cualquier sistema que tenga componentes que reaccionen entre sí sin estar directamente acoplados, como notificaciones o actualizaciones de UI. Y Factory me permitirá mantener un código limpio y organizado cuando necesite crear muchos objetos similares con diferencias pequeñas. Son herramientas poderosas que aportan claridad y escalabilidad al proyecto.

#### **6. Relevancia interdisciplinar**
Sí, creo que entender estos patrones es muy útil incluso para artistas o creativos que programan ocasionalmente. Muchas veces, cuando alguien está trabajando en arte generativo, instalaciones interactivas o animaciones complejas, el código empieza a crecer rápidamente y se vuelve difícil de mantener. Usar patrones como State o Observer puede hacer que esos proyectos sean más sostenibles en el tiempo, más fáciles de modificar, y más comprensibles incluso para otras personas que quieran colaborar. Además, permiten separar mejor la lógica de interacción, el diseño visual y la funcionalidad, lo que mejora la calidad técnica sin limitar la creatividad. Es una manera de convertir el caos creativo en un sistema flexible y reutilizable.